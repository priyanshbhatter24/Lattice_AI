import google.generativeai as genai
import httpx
import json
import structlog
from PIL import Image
from io import BytesIO

from app.config import get_settings

logger = structlog.get_logger()

MATCHING_PROMPT = """You are an expert location scout for film production. Evaluate how well this location matches the scene requirements.

SCENE REQUIREMENTS:
- Slugline: {slugline}
- Type: {int_ext}
- Time of Day: {time_of_day}
- Description: {description}
- Mood: {mood}
- Period: {period}
- Key Requirements: {requirements}

LOCATION:
- Name: {location_name}
- Description: {location_description}
- Address: {location_address}
- Amenities: {amenities}

I'm showing you {num_images} images of this location.

Rate this location for the scene on a scale of 0-100 for each category:

1. **Visual Match** (0-100): How well does the visual aesthetic, architecture, and atmosphere match the scene description?
2. **Functional Fit** (0-100): Does the space have the required features, size, and layout for filming?
3. **Logistics Score** (0-100): Consider accessibility, parking, noise levels, and practical filming considerations.

Provide your response as JSON:
```json
{{
  "visual_score": <0-100>,
  "functional_score": <0-100>,
  "logistics_score": <0-100>,
  "overall_score": <0-100>,
  "reasoning": "<2-3 sentence explanation of the scores>"
}}
```

Return ONLY the JSON, no other text.
"""


async def score_location_for_scene(scene: dict, location: dict) -> dict:
    """Score a location against scene requirements using Gemini multimodal."""
    settings = get_settings()
    genai.configure(api_key=settings.gemini_api_key)

    model = genai.GenerativeModel("gemini-1.5-flash")

    # Build the prompt
    prompt = MATCHING_PROMPT.format(
        slugline=scene.get("slugline", "Unknown"),
        int_ext=scene.get("int_ext", "Unknown"),
        time_of_day=scene.get("time_of_day", "Unknown"),
        description=scene.get("description", "No description"),
        mood=scene.get("mood", "Unknown"),
        period=scene.get("period", "Unknown"),
        requirements=", ".join(scene.get("requirements", [])),
        location_name=location.get("name", "Unknown"),
        location_description=location.get("description", "No description"),
        location_address=location.get("address", "Unknown"),
        amenities=", ".join(location.get("amenities", [])),
        num_images=len(location.get("images", [])),
    )

    # Prepare content with images
    content = [prompt]

    # Download and add images
    images = location.get("images", [])[:5]  # Max 5 images
    for img_url in images:
        try:
            image = await download_image(img_url)
            if image:
                content.append(image)
        except Exception as e:
            logger.warning("Failed to download image", url=img_url, error=str(e))

    try:
        response = model.generate_content(content)
        response_text = response.text.strip()

        # Clean up response
        if "```json" in response_text:
            response_text = response_text.split("```json")[1].split("```")[0].strip()
        elif "```" in response_text:
            response_text = response_text.split("```")[1].split("```")[0].strip()

        scores = json.loads(response_text)

        # Validate scores
        for key in ["visual_score", "functional_score", "logistics_score", "overall_score"]:
            if key not in scores:
                scores[key] = 50  # Default to middle score
            scores[key] = max(0, min(100, int(scores[key])))  # Clamp to 0-100

        if "reasoning" not in scores:
            scores["reasoning"] = "Score generated by AI matcher"

        logger.info(
            "Location scored",
            location=location.get("name"),
            overall_score=scores["overall_score"],
        )

        return scores

    except json.JSONDecodeError as e:
        logger.error("Failed to parse Gemini scoring response", error=str(e))
        # Return default scores
        return {
            "visual_score": 50,
            "functional_score": 50,
            "logistics_score": 50,
            "overall_score": 50,
            "reasoning": "Could not generate detailed score",
        }
    except Exception as e:
        logger.error("Scoring failed", error=str(e))
        raise


async def download_image(url: str) -> Image.Image | None:
    """Download an image from URL and return as PIL Image."""
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, timeout=10.0, follow_redirects=True)
            if response.status_code == 200:
                image = Image.open(BytesIO(response.content))
                # Resize if too large
                max_size = 1024
                if max(image.size) > max_size:
                    image.thumbnail((max_size, max_size))
                return image
    except Exception as e:
        logger.warning("Image download failed", url=url, error=str(e))
    return None
